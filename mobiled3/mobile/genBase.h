//
//
//

#ifndef _GENBASE_H_
#define _GENBASE_H_

#include "thread/condition.h"
#include "mobile/mobiletypes.h"
#include "mobile/motorFeeder.h"
#include "localisation/localisation.h"
#include "localization/localization.h"
#include "localization/correspondence.h"
#include "iotypes.h"
#include "./map.h"
#include "./motion/motion.h"   // CVEC
#include "./defines.h"
#include "./periodicTimer.h"
#include "./voltageDisplayThread.h"
#include "./laserFeeder.h"   // units.h
#include "./laser.h"

///////////////////////////////////////////////////////////////////////////////
///
/// Hauptklasse der Robotersteuerung <i>mobiled</i>.
///
///////////////////////////////////////////////////////////////////////////////
class CGENBASE : protected CPERIODICTIMER
{
  /////////////////////////////////////////////////////////////////////////////////////////
  /// Steuerung der Motoren. Ruft 'UpdateOdometry() ' auf.
  /////////////////////////////////////////////////////////////////////////////////////////

  friend class CMOTORFEEDER;   

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Ansteuerung der Laserscanner. Ruft 'UpdateLaser()' auf.
  /////////////////////////////////////////////////////////////////////////////////////////

  friend class CLASERFEEDER;  

  /////////////////////////////////////////////////////////////////////////////////////////
  /// TCP/IP-Interface von 'mobiled', Braucht Zugriff auf die Karte
  /////////////////////////////////////////////////////////////////////////////////////////

  friend class CCLIENT;

private:

  /////////////////////////////////////////////////////////////////////////////////////////
  /// *** nicht implementiert ***
  /////////////////////////////////////////////////////////////////////////////////////////

  CGENBASE (const CGENBASE &);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// *** nicht implementiert ***
  /////////////////////////////////////////////////////////////////////////////////////////

  CGENBASE &operator= (const CGENBASE &);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// *** nicht implementiert ***
  /////////////////////////////////////////////////////////////////////////////////////////

  bool operator== (const CGENBASE &);

protected:

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Zugriff auf die Motoren und weitere Sensoren im Controller Area Network (CAN).
  /////////////////////////////////////////////////////////////////////////////////////////

  CMOTORFEEDER *_motorFeeder;

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Anzeige der Batteriespannung.
  /////////////////////////////////////////////////////////////////////////////////////////

  CVOLTAGEDISPLAYTHREAD * _voltageDisplayThread;

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Zugriff auf die Laserscanner.
  /////////////////////////////////////////////////////////////////////////////////////////
  
  CLASERFEEDER *_laserFeeder;

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Zeiger auf die auszuführende Bewegung. 
  /////////////////////////////////////////////////////////////////////////////////////////

  volatile _CMOTION *_motion;

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Siehe 'WaitIdleCondition()'.
  /////////////////////////////////////////////////////////////////////////////////////////

  CCONDITION _idleCondition;

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Soll die aktuelle Bewegung abgebrochen werden?
  /////////////////////////////////////////////////////////////////////////////////////////

  bool _abortCurrentMotion;

  //

  const double _transVelMax;
  const double _transAccMax;
  const double _rotVelMax;
  const double _rotAccMax;

  double _transVelScale;
  double _rotVelScale;

  struct timeval _lastEvent;

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Periodisch aufgerufene Methode und Kern der Steuerung/Lokalisierung.
  /////////////////////////////////////////////////////////////////////////////////////////

  virtual void Event (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Berechnet die Zeit die seit dem letzten Aufruf von Event() 
  // vergangen ist in Microsekunden.
  /////////////////////////////////////////////////////////////////////////////////////////
  
  const microseconds_t GetEventInterval (void);
  
  /////////////////////////////////////////////////////////////////////////////////////////
  /// Aufzeichnen der Odometriewerte.
  /////////////////////////////////////////////////////////////////////////////////////////

  bool _logOdometry;              

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Ist der Roboter zu dicht an einem Hinderniss?
  /////////////////////////////////////////////////////////////////////////////////////////

  bool _isStalled;           

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Zustand der Bremsen (angezogen|gelöst)
  /////////////////////////////////////////////////////////////////////////////////////////

  bool _brakesEnabled;          

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Neue Selbst-Lokalisierung
  /////////////////////////////////////////////////////////////////////////////////////////

  CLOCALIZATION *_localization;
  CCORRESPONDENCE *_correspondence;

  //
  // localisation stuff
  //

  CMAP _map;

  Localisation *_localisation;
  Localisation *_localisationOdo;

  CVEC GetState (void);   // for subroutines that have no access to `_localization'.

  CVEC _kalmanState;   // used internally in UpdateOdometry

  void UpdateOdometry (const double deltaPosLeft,
		       const double deltaPosRight,
		       const double deltaPosGyro);

  FILE *_laserLogFile;
  void UpdateLaser (CVEC &marks);
  void UpdateLaser (CVEC &marks, int *matched);

  MOBILEMODE _mode;

public:

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Konstruktor.
  /////////////////////////////////////////////////////////////////////////////////////////

  CGENBASE (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Destruktor.
  /////////////////////////////////////////////////////////////////////////////////////////

  virtual ~CGENBASE (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  ///
  /// use these to synchronize motions. any thread wishing to issue a motion
  /// should call `WaitIdleCondition()' to wait until the platform is
  /// idle. After setting up the motion parameters and making `_motion' point to
  /// it it should call `UnlockIdleCondition()' to give other threads a chance
  /// to wake up (probably only to go to sleep again immediately if they were
  /// waiting for idleness too). the main control thread will call
  /// `SignalIdleCondition()' whenever a motions terminates.
  ///
  /// the idea is that with `MotionRotate()' and `MotionTranslate()' this
  /// behaviour is already built-in, whereas with `MotionMove()' it is not. this
  /// is because `MotionMove()' already takes a complete path as argument and it
  /// would therefore be too late if it would wait until the platform is idle
  /// because all this waiting is just to ensure that the path planner (which is
  /// not meant to be linked to CGENBASE too closely) sees the correct current
  /// position as start point of the path.
  ///
  /////////////////////////////////////////////////////////////////////////////////////////

  void WaitIdleCondition (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Siehe 'WaitIdleCondition()'.
  /////////////////////////////////////////////////////////////////////////////////////////

  void UnlockIdleCondition (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Siehe 'WaitIdleCondition()'.
  /////////////////////////////////////////////////////////////////////////////////////////

  void SignalIdleCondition (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  ///
  /////////////////////////////////////////////////////////////////////////////////////////

  int GetPos    (meter_t &x, meter_t &y, radiant_t &a);
  
  int GetPosOdo (meter_t &x, meter_t &y, radiant_t &a);

  void GetPosAndVar (meter_t &x, meter_t &y, radiant_t &a,
		     double &varXX, double &varXY,
		     double &varYX, double &varYY,
		     double &varAA);
  void SetPos (const meter_t x, const meter_t y, const radiant_t a);

  /////////////////////////////////////////////////////////////////////////////////////////
  //
  // Laserscanner
  //
  /////////////////////////////////////////////////////////////////////////////////////////

  int GetNumScanners (void) const;

  int GetScannerPosition (meter_t &x, meter_t &y, radiant_t &a, const int idx) const;

  int GetLaserScan (const int idx, CRADIALSCANMATCHED &scan);

  int GetLaserScanPlatform (const int idx, CRADIALSCANMATCHED &scan);

  int GetMarks (CVEC &marks);

  int GetMarks (CVEC &marks, CVEC &variances);

  /////////////////////////////////////////////////////////////////////////////////////////
  //
  // Bewegungen 
  //
  /////////////////////////////////////////////////////////////////////////////////////////

  void AbortCurrentMotion (void);

  void EnableMotion (void);

  int MotionRotateAngle (const double ae, const bool collisionAvoidance);

  int MotionTranslate (const double xe, const double ye);

  int MotionMove (CVEC &path, double ae);

  int MotionForward (const double de);

 private:

  _CMOTION* createMotionToPoint (const double x, 
				 const double y,
				 const double theta,
				 const double xe,
				 const double ye);

 public:

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Zieht die Bremsen der Antriebsmotoren an oder löst sie.
  /////////////////////////////////////////////////////////////////////////////////////////

  int SetBrakes (const bool enable);             

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Gibt zurück, ob die Bremsen der Antriebsmotoren angezogen sind.
  /////////////////////////////////////////////////////////////////////////////////////////

  bool AreBrakesEnabled (void);      

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Liefert die Batteriespannung.
  /////////////////////////////////////////////////////////////////////////////////////////

  double GetBatteryVoltage (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Liefert zurück, ob der Roboter zu nah an einem Hinderniss ist.
  /////////////////////////////////////////////////////////////////////////////////////////

  bool Stalled (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Liefert die Temperaturen der Antriebsmotoren.
  /////////////////////////////////////////////////////////////////////////////////////////

  double* GetDriveTemperatures (void);

  /////////////////////////////////////////////////////////////////////////////////////////
  /// Liefert zurück, ob die aktuelle Bewegung beendet ist.
  /////////////////////////////////////////////////////////////////////////////////////////

  bool IsCompleted (void) const;

  void GetScale (double &transScale, double &rotScale) const;

  void SetScale (const double transScale,
		 const double rotScale,
		 double &transScaleRet,
		 double &rotScaleRet);

  void ModifyScale (const double transScaleFactor,
		    const double rotScaleFactor,
		    double &transScaleOld,
		    double &rotScaleOld);

  MOBILEMODE GetMode (void) const;

  MOBILEMODE SetMode (const MOBILEMODE mode);

  //
};

#endif
