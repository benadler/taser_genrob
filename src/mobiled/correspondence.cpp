#include "correspondence.h"

static inline float sqr(const float &a)
{
	return a*a;
}

// Initialize the singleton-pointer to NULL
QMutex Correspondence::singletonMutex;
Correspondence* Correspondence::singleton = NULL;

Correspondence* Correspondence::instance()
{
	QMutexLocker locker(&singletonMutex);

	if(singleton == NULL)
		singleton = new Correspondence();

	return singleton;
}

Correspondence::Correspondence()
{
	logger = Logger::instance();
	logger->Correspondence("Correspondence::Correspondence() created in thread id %d.", syscall(SYS_gettid));

	java = Java::instance();

	connect
	(
		java,
		SIGNAL(laserMarksReady(QList<LaserMarkKnown>)),
		SLOT(slotReceiveKnownLaserMarksFromGenMap(QList<LaserMarkKnown>))
	);

	//loadKnownLaserMarksFromFile(Configuration::instance()->getKnownLaserMarksFilename());
	requestKnownLaserMarksFromGenMap();
}

void Correspondence::requestKnownLaserMarksFromGenMap(void)
{
	logger->Correspondence("Correspondence::requestKnownLaserMarksFromGenMap(): requesting KnownLaserMarks from genMap via queued connection/JNI...");

	QMetaObject::invokeMethod
	(
		java,
		"slotRequestLaserMarksFromGenMap",
		Qt::QueuedConnection
	);
}

void Correspondence::slotReceiveKnownLaserMarksFromGenMap(QList<LaserMarkKnown> laserMarks)
{
	logger->Correspondence("Correspondence::slotReceiveKnownLaserMarksFromGenMap(): saving %d received laserMarks", laserMarks.size());
	knownLaserMarks = laserMarks;
}

bool Correspondence::loadKnownLaserMarksFromFile(const QString filename)
{
	logger->Correspondence("Correspondence::loadKnownLaserMarksFromFile(): loading KnownLaserMarks from %s", qPrintable(filename));
	// open file for reading
	QFile laserMarksFile(filename);

	// test if file has been opened, if not terminate program
	if(!laserMarksFile.open(QIODevice::ReadOnly | QIODevice::Text))
	{
		logger->Correspondence("Correspondence::loadKnownLaserMarksFromFile(): cannot open file %s", qPrintable(filename));
		return false;
	}

	knownLaserMarks.clear();

	int lineNumber = 1;

	QTextStream laserMarksStream(&laserMarksFile);
	while (!laserMarksStream.atEnd() && lineNumber++)
	{
		QString line = laserMarksStream.readLine();

		if(line.left(1) != QChar('#') && !line.isEmpty() && line.left(1) != QChar(';'))
		{
			bool conversionXOK, conversionYOK;
			// the file has one mark per line, specified in millimeters, separated by a space.
			int mmX = line.section(' ', 0, 0, QString::SectionSkipEmpty).toInt(&conversionXOK);
			int mmY = line.section(' ', 1, 1, QString::SectionSkipEmpty).toInt(&conversionYOK);

			if(conversionXOK && conversionYOK)
				knownLaserMarks.append(LaserMarkKnown(QPointF(mmX / 1000.0, mmY / 1000.0)));
			else
			{
				logger->Correspondence("Correspondence::loadKnownLaserMarksFromFile()(): failed to load known laserMarks in file %s:%d.", qPrintable(filename), lineNumber);
				return false;
			}
		}
	}

	laserMarksFile.close();
	return true;
}

bool Correspondence::saveKnownLaserMarksToFile(const QString filename) const
{
	logger->Correspondence("Correspondence::saveKnownLaserMarksToFile(): saving KnownLaserMarks to %s", qPrintable(filename));

	// open file for writing
	QFile laserMarksFile(filename);

	// test if file has been opened, if not terminate program
	if(!laserMarksFile.open(QIODevice::WriteOnly | QIODevice::Text))
	{
		logger->Correspondence("Correspondence::saveKnownLaserMarksToFile(): cannot open file %s for writing.", qPrintable(filename));
		return false;
	}

	QTextStream out(&laserMarksFile);

	out << "#\n# This file lists known lasermarks. It was generated by mobileD's\n";
	out << "# Correspondence::saveKnownLaserMarks() on " << QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss") << ".\n";
	out << "#\n# Lines starting with ; or # are comments, one lasermark on each line:\n#\n";
	out << "# x-position [space] y-position\n#\n";
	out << "# Positions are in millimeters.\n";
	out << "#\n# DO NOT EDIT THIS FILE WHILE MOBILED IS RUNNING, changes will be lost.\n#\n";
	out << "\n";

	foreach(const LaserMarkKnown &currentMark, knownLaserMarks)
		out << currentMark.toString() << "\n";

	laserMarksFile.close();
	return true;
}

Correspondence::~Correspondence(void)
{
	//logger->Correspondence("Correspondence::~Correspondence: saving known laserMarks to file %s", qPrintable(Configuration::instance()->getKnownLaserMarksFilename()));
	//saveKnownLaserMarksToFile(Configuration::instance()->getKnownLaserMarksFilename());
}

void Correspondence::getKnownMarks(QList<LaserMarkKnown> &knownMarks) const
{
	knownMarks = knownLaserMarks;
}

bool Correspondence::getMatchingMark(const Pose &pose, const LaserMarkMeasured markMeasured, LaserMarkKnown &knownMark)
{
	QTransform platformToWorld;

	platformToWorld.translate(pose.getX(), pose.getY());
	// for some reason, we have to rotate the transform 90 degrees clockwise!
	platformToWorld.rotate(-90.0);
	platformToWorld.rotateRadians(pose.getAngleRad());

	// Where in the world is the measured laserMark?
	QPointF pointLaserMarkMeasured(markMeasured.getPlatformCoordinate());
// 	pointLaserMarkMeasured.setX(-pointLaserMarkMeasured.x());
	pointLaserMarkMeasured = platformToWorld.map(pointLaserMarkMeasured);
// 	pointLaserMarkMeasured.setY(-pointLaserMarkMeasured.y());
/*
	logger->Correspondence("Correspondence::getMatchingMark: pose %s, platform %.2F/%.2F is world %.2F/%.2F.",
		qPrintable(pose.toString()),
		markMeasured.getPlatformCoordinate().x(),
		markMeasured.getPlatformCoordinate().y(),
		pointLaserMarkMeasured.x(),
		pointLaserMarkMeasured.y());
*/
	float minimumSquaredDistance = 9999.9;
	int closestMark = -1;

	// Check all known marks
	for(int markNumber=0; markNumber < knownLaserMarks.size(); ++markNumber)
	{
		//logger->Correspondence("Correspondence::getMatchingMark(): Ueberpruefe Marke %d (%d, %d)", markNumber, knownLaserMarks[markNumber].getX(), knownLaserMarks[markNumber].getY());

		// Calculate distance between measured laserMark and this known mark.
		float distanceBetweenMarksX = pointLaserMarkMeasured.x() - knownLaserMarks[markNumber].getWorldCoordinate().x();
		float distanceBetweenMarksY = pointLaserMarkMeasured.y() - knownLaserMarks[markNumber].getWorldCoordinate().y();
		float currentSquaredDistance = sqr(distanceBetweenMarksX) + sqr(distanceBetweenMarksY);

		if(currentSquaredDistance < minimumSquaredDistance)
		{
			closestMark = markNumber;
			minimumSquaredDistance = currentSquaredDistance;
		}
	}

	if(minimumSquaredDistance < sqr(0.9))
	{
		// we found a knownLaserMark that is closer to our measured mark than 0.3m. Use it!
		knownMark = knownLaserMarks[closestMark];

/*		logger->Correspondence("Correspondence::getMatchingMark: matched (%.2Fm): %s: %s.",
			sqrt(minimumSquaredDistance),
			qPrintable(markMeasured.toString()),
			qPrintable(knownMark.toString())
		);
*/

		return true;
	}

/*	logger->Correspondence("Correspondence::getMatchingMark: no match mark world %.2F/%.2F, best match was %s, %.2F away.",
		pointLaserMarkMeasured.x(),
		pointLaserMarkMeasured.y(),
		qPrintable(knownLaserMarks.at(closestMark).toString()),
		sqrt(minimumSquaredDistance)
	);
*/

	return false;
}
